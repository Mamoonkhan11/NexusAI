export function ChatPageClient({ initialMessages }: ChatPageClientProps) {
  const [messages, setMessages] = useState<Message[]>(initialMessages)
  const [input, setInput] = useState("")
  const [isSidebarOpen, setIsSidebarOpen] = useState(true)
  const [chatSessions, setChatSessions] = useState<any[]>([])
  const [activeChatId, setActiveChatId] = useState<string | null>(null)
  const [selectedAgent, setSelectedAgent] = useState("General Assistant")
  const [selectedModel, setSelectedModel] = useState("Auto")
  const [isLoading, setIsLoading] = useState(false)

  const bottomRef = useRef<HTMLDivElement>(null)

  // Load chat sessions on mount
  useEffect(() => {
    const loadSessions = async () => {
      try {
        const res = await fetch('/api/chat/sessions?t=' + Date.now(), {
          cache: 'no-store'
        })
        const json = await res.json()
        if (json?.success && Array.isArray(json.sessions)) {
          setChatSessions(json.sessions)
          if (json.sessions.length > 0 && !activeChatId) {
            const first = json.sessions[0]
            setActiveChatId(first.id)
            // Load messages for the first session
            const mres = await fetch(`/api/chat/sessions/${first.id}/messages?t=${Date.now()}`, {
              cache: 'no-store'
            })
            const mjson = await mres.json()
            if (mjson?.success && Array.isArray(mjson.messages)) {
              setMessages(mjson.messages)
            }
          }
        }
      } catch (err) {
        console.error('Failed to load sessions:', err)
      }
    }
    loadSessions()
  }, [])

  // Scroll to bottom when messages change
  useEffect(() => {
    try { bottomRef.current?.scrollIntoView({ behavior: "smooth" }) } catch {}
  }, [messages])

  const checkApiKeyAvailability = (model: string) => {
    if (model === "Auto") return true
    const providerMap: Record<string, string> = {
      "ChatGPT": "openai",
      "Gemini": "gemini",
      "Claude": "claude",
      "Groq": "groq"
    }
    const provider = providerMap[model]
    return !!(provider && (process.env[`${provider.toUpperCase()}_API_KEY`] || localStorage.getItem(`${provider}_key`)))
  }

  const aiAgents = [
    { name: "General Assistant", prompt: "You are a versatile AI assistant capable of helping with various tasks." },
    { name: "Code Assistant", prompt: "You are an expert software developer. Provide detailed, accurate code solutions with explanations." },
    { name: "Writing Assistant", prompt: "You are a professional writing assistant. Help with grammar, style, content creation, and editing." },
    { name: "Math Tutor", prompt: "You are a patient math tutor. Explain concepts clearly and provide step-by-step solutions." },
    { name: "Research Assistant", prompt: "You are a research assistant. Help with information gathering, analysis, and synthesis." }
  ]

  const handleSendMessage = async (formData: FormData, isRegenerate: boolean = false) => {
    const message = formData.get("message") as string

    // No single provider is mandatory â€” allow sending and let the server routeToAI choose available providers.

    // Check specific model availability
    if (!checkApiKeyAvailability(selectedModel)) {
      const modelName = selectedModel === "Auto" ? "any AI model" : selectedModel
      toast.error("API Key Required", {
        description: `${modelName} API key not found. Please add it in the API Keys section.`,
        action: {
          label: "Go to Settings",
          onClick: () => window.location.href = "/dashboard/api-keys"
        }
      })
      return
    }

    // Ensure we have an active session - create one if needed
    let currentSessionId = activeChatId
    if (!currentSessionId) {
      try {
        const res = await fetch("/api/chat/create-session", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ title: "" }),
        })
        const json = await res.json()
        if (json?.success && json?.session) {
          currentSessionId = json.session.id
          setActiveChatId(currentSessionId)
          setChatSessions((prev) => [json.session, ...prev])
        } else {
          toast.error("Failed to create chat session")
          return
        }
      } catch (err) {
        console.error("Failed to create session:", err)
        toast.error("Failed to create chat session")
        return
      }
    }

    // Find the most recent file message to analyze
    const recentFileMessage = [...messages].reverse().find(msg => msg.fileUrl && msg.role === "user")
    const fileUrl = recentFileMessage?.fileUrl

    if (!message.trim() && !fileUrl) {
      toast.error("Empty message", { description: "Please enter a message or upload a file before sending." })
      return
    }

    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: fileUrl ? `Please analyze this file: ${message || "Provide insights about the uploaded file."}` : message,
      fileUrl,
      fileName: fileUrl ? recentFileMessage?.fileName : undefined,
      fileType: fileUrl ? recentFileMessage?.fileType : undefined
    }

    // Prepare chat history with system message
    const agentPrompt = aiAgents.find(a => a.name === selectedAgent)?.prompt ||
                        "You are a versatile AI assistant capable of helping with various tasks."

    // Prepare chat history with system message
    const historyForServer = [
      { role: "system", content: agentPrompt },
      ...messages.map(msg => ({
        role: msg.role,
        content: msg.content
      }))
    ]

    // For regenerate, remove the last AI message
    if (isRegenerate) {
      const lastUserMessage = messages[messages.length - 1]?.lastUserMessage
      if (lastUserMessage) {
        // Remove last AI message and add the user message again
        setMessages(prev => prev.slice(0, -1))
        historyForServer.splice(-1) // Remove the last AI message from history
      }
    } else {
      // Add current message to history for server
      historyForServer.push({ role: "user", content: message })
    }

    formData.append("history", JSON.stringify(historyForServer))
    formData.append("systemMessage", agentPrompt)
    formData.append("selectedModel", selectedModel)

    // Add sessionId - we now always have one
    if (currentSessionId) {
      formData.append("sessionId", currentSessionId)
    }

    // Update UI immediately (only if not regenerating)
    if (!isRegenerate) {
      setMessages((prev) => [...prev, userMessage])
      setInput("")

      // Add optimistic UI feedback
      console.log(`[UI] Message sent, awaiting AI response...`)
    }

    setIsLoading(true)

    try {
      const response = await fetch("/dashboard/chat", {
        method: "POST",
        body: formData
      })

      if (response.ok) {
        if (response.headers.get("content-type")?.includes("text/plain")) {
          // Handle streaming response
          const reader = response.body?.getReader()
          if (!reader) throw new Error("No response body")

          const decoder = new TextDecoder()
          let accumulatedContent = ""
          const aiMessageId = (Date.now() + 1).toString()
          let aiMessage: Message = {
            id: aiMessageId,
            role: "assistant",
            content: "",
            lastUserMessage: message
          }

          setMessages((prev) => [...prev, aiMessage])

          try {
            while (true) {
              const { done, value } = await reader.read()
              if (done) break

              const chunk = decoder.decode(value, { stream: true })
              accumulatedContent += chunk

              // Update the AI message content in real-time
              setMessages((prev) => prev.map((msg) =>
                msg.id === aiMessageId ? { ...msg, content: accumulatedContent } : msg
              ))
            }

            // Save chat history after streaming completes
            const chatHistoryMessages = [
              ...messages,
              { role: "assistant", content: accumulatedContent, lastUserMessage: message }
            ]

            // Truncate history if longer than 10 exchanges (roughly 20 messages)
            const maxMessages = 20
            if (chatHistoryMessages.length > maxMessages) {
              // Keep system message if present, then most recent messages
              const systemMessages = chatHistoryMessages.filter(msg => msg.role === "system")
              const recentMessages = chatHistoryMessages.slice(-maxMessages + systemMessages.length)
              chatHistoryMessages.splice(0, chatHistoryMessages.length, ...systemMessages, ...recentMessages)
            }

            try {
              await fetch('/dashboard/chat/api/save-history', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ messages: chatHistoryMessages }),
              })
            } catch (historyError) {
              console.error("Failed to save chat history:", historyError)
            }
          } finally {
            reader.releaseLock()
          }
        } else {
          // Handle regular response object
          const result = await response.json()

          if (result.error) {
            // Specific toast messages for different error types
            if (result.error.includes("does not have credits") ||
                result.error.includes("upgrade billing") ||
                result.error.includes("Insufficient credit balance") ||
                (result.error.toLowerCase().includes("insufficient") &&
                 (result.error.toLowerCase().includes("credit") || result.error.toLowerCase().includes("balance") || result.error.toLowerCase().includes("quota")))) {
              toast.error("Insufficient Credits", { description: "This API key does not have credits. Please upgrade billing or try a different provider." })
            } else if (result.error.includes("not accessible with your key") ||
                       result.error.includes("choose another model")) {
              toast.error("Model Not Accessible", { description: "This model is not accessible with your key, choose another model." })
            } else if (result.error.includes("Invalid") && result.error.includes("key")) {
              toast.error("Invalid API Key", { description: "Please check your API keys in settings." })
            } else if (result.error.includes("No API key")) {
              toast.error("No API Keys Found", { description: "Please add API keys in the settings." })
            } else if (result.error.includes("Rate limit")) {
              toast.error("Rate Limit Hit", { description: "Please wait a moment before sending another message." })
            } else if (result.error.includes("Provider unavailable")) {
              toast.error("Provider Unavailable", { description: "The selected AI provider is currently unavailable." })
            } else {
              toast.error("Chat Error", { description: result.error })
            }
          } else if (result.reply) {
            const aiMessage: Message = {
              id: (Date.now() + 1).toString(),
              role: "assistant",
              content: result.reply,
              lastUserMessage: message,
            }
            setMessages((prev) => [...prev, aiMessage])
            console.log(`[UI] AI response received, message added to chat`)
          } else {
            // Response object exists but doesn't have expected properties
            console.error("Response object missing expected properties:", result)
            toast.error("Response Error", { description: "The server returned an incomplete response. Please try again." })
          }
        }
      } else {
        const errorData = await response.json().catch(() => ({}))
        toast.error("Request Failed", { description: errorData.error || "An error occurred while sending your message." })
      }
    } catch (error: any) {
      console.error("Error sending message:", error)
      toast.error("Network Error", { description: "Failed to send message. Please check your connection and try again." })
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="h-screen flex bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900">
      {/* Sidebar */}
      {isSidebarOpen && (
        <aside className="w-64 border-r border-white/20 backdrop-blur-xl bg-slate-900/60 flex flex-col">
          <div className="p-3 border-b border-white/20 flex items-center justify-between">
            <h2 className="text-white/90 font-semibold">Chat Sessions</h2>
            <Button
              size="icon"
              variant="ghost"
              className="text-white/60 hover:text-white hover:bg-white/20"
              onClick={() => setIsSidebarOpen(false)}
            >
              <X className="size-4" />
            </Button>
          </div>

          <ScrollArea className="flex-1">
            <div className="p-3 space-y-2">
              {chatSessions.map((session) => (
                <div key={session.id} className="relative">
                  <Button
                    variant="ghost"
                    className={cn(
                      "w-full justify-start gap-2 text-left text-white/80 hover:text-white hover:bg-white/15",
                      activeChatId === session.id && "bg-white/15 text-white border border-cyan-400/40 shadow-lg",
                    )}
                    onClick={() => {
                      setActiveChatId(session.id)
                      // Load messages for this session
                      fetch(`/api/chat/sessions/${session.id}/messages?t=${Date.now()}`, {
                        cache: 'no-store'
                      }).then(res => res.json()).then(json => {
                        if (json?.success && Array.isArray(json.messages)) {
                          setMessages(json.messages)
                        }
                      }).catch(err => console.error('Failed to load messages:', err))
                    }}
                  >
                    <MessageSquare className="size-4 text-cyan-400 flex-shrink-0" />
                    <div className="flex-1 min-w-0">
                      <div className="text-sm font-medium truncate">
                        {session.title || "New Chat"}
                      </div>
                      <div className="text-xs text-white/60 truncate">
                        {session.timestamp}
                      </div>
                    </div>
                  </Button>

                  <div className="absolute right-1 top-1/2 -translate-y-1/2">
                    <Button
                      size="icon"
                      variant="ghost"
                      onClick={async (e) => {
                        e.stopPropagation()
                        if (!confirm("Delete this chat session and all its messages permanently? This action cannot be undone.")) return

                        const deletedSessionId = session.id

                        // Optimistically remove from UI immediately
                        setChatSessions((prev) => prev.filter((s) => s.id !== deletedSessionId))

                        // If this was the active session, clear it
                        if (activeChatId === deletedSessionId) {
                          setActiveChatId(null)
                          setMessages([]) // Clear messages immediately
                          // Clear any pending inputs
                          setInput("")
                        }

                        try {
                          // Delete from server
                          const del = await fetch(`/api/chat/sessions/${deletedSessionId}/delete`, {
                            method: "DELETE",
                            cache: "no-store",
                            headers: {
                              "Cache-Control": "no-cache",
                              "Pragma": "no-cache"
                            }
                          })
                          const j = await del.json()

                          if (j?.success) {
                            // Clear local state first to prevent showing stale data
                            setMessages([])

                            // Small delay to ensure UI updates before loading new data
                            await new Promise(resolve => setTimeout(resolve, 50))

                            // Reload sessions from server to ensure consistency
                            const res = await fetch(`/api/chat/sessions?t=${Date.now()}&cb=${Math.random()}`, {
                              cache: "no-store",
                              headers: {
                                "Cache-Control": "no-cache, no-store, must-revalidate",
                                "Pragma": "no-cache",
                                "Expires": "0"
                              }
                            })
                            const json = await res.json()

                            if (json?.success && Array.isArray(json.sessions)) {
                              // Force update with server response
                              setChatSessions(json.sessions)

                              // If we deleted the active session and there are other sessions, load the first one
                              if (activeChatId === null && json.sessions.length > 0) {
                                const first = json.sessions[0]
                                setActiveChatId(first.id)
                                // Load messages for the new active session
                                const mres = await fetch(`/api/chat/sessions/${first.id}/messages?t=${Date.now()}&cb=${Math.random()}`, {
                                  cache: "no-store",
                                  headers: {
                                    "Cache-Control": "no-cache, no-store, must-revalidate",
                                    "Pragma": "no-cache",
                                    "Expires": "0"
                                  }
                                })
                                const mjson = await mres.json()
                                if (mjson?.success && Array.isArray(mjson.messages)) {
                                  setMessages(mjson.messages)
                                } catch (err) {
                                  // If no messages loaded, keep empty state
                                  setMessages([])
                                }
                              }
                            } catch (err) {
                              // If session reload failed, keep empty state
                              setMessages([])
                            }

                            // Verify deleted session is not in the list
                            const stillExists = json.sessions?.find((s: any) => s.id === deletedSessionId)
                            if (stillExists) {
                              // Session still exists, remove it again
                              setChatSessions((prev) => prev.filter((s) => s.id !== deletedSessionId))
                            }
                          }

                          toast.success("Chat session and all messages deleted permanently")
                        } catch (err) {
                          // Server deletion failed, but we already removed from UI
                          // Reload to get accurate state
                          const res = await fetch(`/api/chat/sessions?t=${Date.now()}&cb=${Math.random()}`, {
                            cache: "no-store",
                            headers: {
                              "Cache-Control": "no-cache, no-store, must-revalidate",
                              "Pragma": "no-cache",
                              "Expires": "0"
                            }
                          })
                          const json = await res.json()
                          if (json?.success && Array.isArray(json.sessions)) {
                            setChatSessions(json.sessions)
                          }
                          toast.error(j?.error || "Failed to delete session")
                        }
                      } catch (err) {
                        console.error("Failed to delete session:", err)
                        // Reload sessions to get accurate state
                        try {
                          // Clear local messages first
                          setMessages([])

                          const res = await fetch(`/api/chat/sessions?t=${Date.now()}&cb=${Math.random()}`, {
                            cache: "no-store",
                            headers: {
                              "Cache-Control": "no-cache, no-store, must-revalidate",
                              "Pragma": "no-cache",
                              "Expires": "0"
                            }
                          })
                          const json = await res.json()
                          if (json?.success && Array.isArray(json.sessions)) {
                            setChatSessions(json.sessions)
                            // If there are sessions but no active one, set the first as active
                            if (!activeChatId && json.sessions.length > 0) {
                              const first = json.sessions[0]
                              setActiveChatId(first.id)
                              // Load messages for the first session
                              const mres = await fetch(`/api/chat/sessions/${first.id}/messages?t=${Date.now()}&cb=${Math.random()}`, {
                                cache: "no-store",
                                headers: {
                                  "Cache-Control": "no-cache, no-store, must-revalidate",
                                  "Pragma": "no-cache",
                                  "Expires": "0"
                                }
                              })
                              const mjson = await mres.json()
                              if (mjson?.success && Array.isArray(mjson.messages)) {
                                setMessages(mjson.messages)
                              }
                            }
                          }
                        } catch (reloadErr) {
                          console.error("Failed to reload sessions after deletion:", reloadErr)
                        }
                        toast.error("Failed to delete session")
                      }
                    }}
                    className="text-red-400 hover:text-red-300"
                  >
                    <X className="size-4" />
                  </Button>
                </div>
              ))}
            </div>
          </ScrollArea>

          <div className="p-3 border-t border-white/20">
            <Button
              variant="ghost"
              className="w-full justify-start gap-2 text-white/80 hover:text-white hover:bg-white/15"
              onClick={() => (window.location.href = "/dashboard")}
            >
              <Home className="size-5 text-cyan-400" />
              <span>Home</span>
            </Button>
          </div>
        </aside>
      )}

      {/* Main Chat Area */}
      <div className="flex-1 flex flex-col h-full overflow-hidden">
        <div className="p-2 border-b border-white/20 backdrop-blur-xl bg-slate-900/60 flex items-center justify-between">
          {!isSidebarOpen && (
            <Button
              size="icon"
              variant="ghost"
              className="text-white/80 hover:text-white hover:bg-white/20"
              onClick={() => setIsSidebarOpen(true)}
            >
              <MessageSquare className="size-5" />
            </Button>
          )}

          <div className={cn("flex-1", !isSidebarOpen && "ml-2")}>
            <div className="flex gap-2">
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    className="gap-2 text-white/90 hover:text-white hover:bg-white/15 border border-white/20 backdrop-blur-md"
                  >
                    <Sparkles className="size-4 text-cyan-400" />
                    <span className="font-medium">{selectedAgent}</span>
                    <ChevronDown className="size-4 text-white/60" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent
                  className="bg-slate-800/95 backdrop-blur-xl border-white/20 text-white"
                  align="start"
                >
                  {aiAgents.map((agent) => (
                    <DropdownMenuItem
                      key={agent.name}
                      onClick={() => setSelectedAgent(agent.name)}
                      className="hover:bg-white/10"
                    >
                      {agent.name}
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuContent>
              </DropdownMenu>

              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    className="gap-2 text-white/90 hover:text-white hover:bg-white/15 border border-white/20 backdrop-blur-md"
                  >
                    <Bot className="size-4 text-cyan-400" />
                    <span className="font-medium">{selectedModel}</span>
                    <ChevronDown className="size-4 text-white/60" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent
                  className="bg-slate-800/95 backdrop-blur-xl border-white/20 text-white"
                  align="start"
                >
                  <DropdownMenuItem onClick={() => setSelectedModel("Auto")} className="hover:bg-white/10">
                    Auto
                  </DropdownMenuItem>
                  {checkApiKeyAvailability("ChatGPT") && (
                    <DropdownMenuItem onClick={() => setSelectedModel("ChatGPT")} className="hover:bg-white/10">
                      ChatGPT
                    </DropdownMenuItem>
                  )}
                  {checkApiKeyAvailability("Gemini") && (
                    <DropdownMenuItem onClick={() => setSelectedModel("Gemini")} className="hover:bg-white/10">
                      Gemini
                    </DropdownMenuItem>
                  )}
                  {checkApiKeyAvailability("Claude") && (
                    <DropdownMenuItem onClick={() => setSelectedModel("Claude")} className="hover:bg-white/10">
                      Claude
                    </DropdownMenuItem>
                  )}
                  {checkApiKeyAvailability("Groq") && (
                    <DropdownMenuItem onClick={() => setSelectedModel("Groq")} className="hover:bg-white/10">
                      Groq
                    </DropdownMenuItem>
                  )}
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          </div>

          <div className="flex items-center gap-2">
            <Button
              size="icon"
              variant="ghost"
              className="text-white/80 hover:text-white hover:bg-white/20"
              onClick={() => window.location.reload()}
            >
              <RotateCcw className="size-4" />
            </Button>
          </div>
        </div>

        {/* Messages */}
        <ScrollArea className="flex-1 p-4">
          <div className="max-w-4xl mx-auto space-y-4">
            {messages.map((message) => (
              <div key={message.id} className={cn(
                "flex gap-3 p-4 rounded-lg backdrop-blur-md",
                message.role === "user"
                  ? "bg-cyan-500/10 border border-cyan-400/20 ml-auto max-w-[80%]"
                  : "bg-slate-800/50 border border-white/10 max-w-[80%]"
              )}>
                <div className={cn(
                  "flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center",
                  message.role === "user"
                    ? "bg-cyan-500/20 text-cyan-400"
                    : "bg-white/10 text-white/80"
                )}>
                  {message.role === "user" ? (
                    <User className="size-4" />
                  ) : (
                    <Bot className="size-4" />
                  )}
                </div>
                <div className="flex-1 min-w-0">
                  <div className="text-sm text-white/60 mb-1">
                    {message.role === "user" ? "You" : "Assistant"}
                  </div>
                  <div className="text-white/90 leading-relaxed whitespace-pre-wrap">
                    {message.content}
                  </div>
                  {message.fileUrl && (
                    <div className="mt-2 p-2 bg-slate-700/50 rounded border border-slate-600/50">
                      <div className="flex items-center gap-2 text-sm text-white/80">
                        <File className="size-4" />
                        <span>{message.fileName}</span>
                        <span className="text-xs text-white/60">({message.fileType})</span>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            ))}
            <div ref={bottomRef} />
          </div>
        </ScrollArea>

        {/* Input */}
        <div className="p-4 border-t border-white/20 backdrop-blur-xl bg-slate-900/60">
          <form action={handleSendMessage} className="max-w-4xl mx-auto">
            <div className="flex gap-3">
              <div className="flex-1 relative">
                <Textarea
                  name="message"
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  placeholder="Type your message..."
                  className="min-h-[60px] resize-none bg-slate-800/50 border-white/20 text-white placeholder:text-white/50 focus:border-cyan-400/50"
                  onKeyDown={(e) => {
                    if (e.key === "Enter" && !e.shiftKey) {
                      e.preventDefault()
                      if (input.trim() && !isLoading) {
                        handleSendMessage(new FormData(e.currentTarget.form!))
                      }
                    }
                  }}
                />
                {input && (
                  <Button
                    type="button"
                    size="icon"
                    variant="ghost"
                    className="absolute right-2 top-2 text-white/60 hover:text-white"
                    onClick={() => setInput("")}
                  >
                    <X className="size-4" />
                  </Button>
                )}
              </div>
              <Button
                type="submit"
                disabled={!input.trim() || isLoading}
                className="bg-cyan-500 hover:bg-cyan-600 text-white px-6"
              >
                {isLoading ? (
                  <Loader2 className="size-4 animate-spin" />
                ) : (
                  <Send className="size-4" />
                )}
              </Button>
            </div>
          </form>
        </div>
      </div>
    </div>
  )
}